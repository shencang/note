# C/C++

## 未分类

### 1.下面程序段的输出结果是

```c
char *p1 = ”123”, *p2 = ”ABC”, str[50] = “xyz”;
strcpy(str + 2, strcat(p1, p2));
printf(“%s\n”, str);
```

* 出错

```t
原代码有错：p1和p2都指向常量字符串，在常量区，所以不能对其进行操作；改为数组即可，但是用字符串初始化数组时要记得将数组长度加1，因为字符串默认的末尾有一个‘\0’；第二点要注意的是，strcat函数的p1要有足够的空间来容纳p1和p2连接后的串长。

修改为以下代码将可以：
char p1[7] = "123";
char p2[] = "ABC";
char str[50] = "xyz";
strcpy(str + 2, strcat(p1, p2));
printf("%s\n", str);
结果：xy123ABC
```

### 2.下列程序编译时会产生错误，请根据行号选择错误的位置（1,4）

![2](https://i.loli.net/2019/11/21/ATvodGUngmM1ec5.png)

```t
1、3处分别为带参构造函数和不带参构造函数，其中带参构造函数中参数都有默认值，所以4处构造对象时不知道调用1、3中哪个构造函数
```

### 3.程序char c[5]={‘a’,’b’,’\0’,’c’,’\0’}; printf(“%s”,c);}的运行结果是（D ）

* ab

```t
printf函数打印字符串，遇到空字符结束
```

### 4.若有以下定义语句double a[8]，*p=a；int i=5；对数组元素错误的引用是（D）

* p[8]

```t
数组大小为8，最多到p[7],p[8]则越界了。
```

### 5.逻辑运算符两侧运算对象的数据类型（D）

* 可以是任何类型的数据

```t
 逻辑运算符两侧运算对象的值如果是0，则表示假，非0就表示真，不管其

类型是什么。故正确答案为D。
```

### 6.(见以下代码)

```c
unsigned short A = 10;
printf("~A = %u\n", ~A);
char c = 128;
printf("c=%d\n", c);
输出多少？
```

* 4294967285   -128

```t
第一个，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285
第二个，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。这两道题都是在考察二进制向int或uint转换时的最高位处理。
```

### 7.求sizeof(s)

```c
struct s
{
    int x: 3;
    int y: 4;
    int z: 5;
    double a;
}
```

* 16

```t
需要看清楚该结构体中是位操作，三个变量共占用一个int类型的大小，int类型占用4个字节，double占用8个字节。为了实现内存对其，int类型需要填充4个字节的长度。

   有些信息在存储时，并不需要占用一个完整的字节，而只需占用几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进制即可。为了节省存储空间，并使处理简单，C语言提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进制位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。
       题目中的x，y，z是一个int型的3个位域，因此以一个int来计算，a是一个double型，字符对齐，因此共占16个字节。
```

### 8.在创建派生类对象，构造函数的执行顺序（）

* 基类构造函数，派生类对象成员构造函数，派生类本身的构造函数

![8](https://i.loli.net/2019/11/25/U8Q9D7gxbnoaLwl.png)

![8-j](https://i.loli.net/2019/11/25/uUcZ9slJHB5aGwT.png)
