# 构建中···

[java高级工程师](https://blog.csdn.net/weixin_36104843/article/details/88106513)

## 事务

[Java中的事务及使用](https://blog.csdn.net/weixin_37934748/article/details/82774230)

[Java中事务总结详解（精华）](https://www.cnblogs.com/lmyupupblogs/p/10248099.html)

## 定时器

## Spring定时器Quartz的使用

[Quartz使用入门](https://www.cnblogs.com/buyige/p/9443775.html)

[Quartz使用入门-springboot](https://www.cnblogs.com/wadmwz/p/10315481.html)

* SpringBoot三种方式实现定时任务：

``Timer``：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。

``ScheduledExecutorService``：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。

``Spring Task``：Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。

Timer:

```java
public class TestTimer {
    public static void main(String[] args) {
        TimerTask timerTask = new TimerTask() {
            @Override
            public void run() {
                System.out.println("task  run:"+ new Date());
            }
        };
        Timer timer = new Timer();
        //安排指定的任务在指定的时间开始进行重复的固定延迟执行。这里是每3秒执行一次
        timer.schedule(timerTask,10,3000);
    }
}
```

ScheduledExecutorService:

```java

public class TestScheduledExecutorService {
    public static void main(String[] args) {
        ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
        // 参数：1、任务体 2、首次执行的延时时间
        //      3、任务执行间隔 4、间隔时间单位
        service.scheduleAtFixedRate(()->System.out.println("task ScheduledExecutorService "+new Date()), 0, 3, TimeUnit.SECONDS);
    }
}
```

Spring Task:

```java

@Slf4j
@Component
@EnableScheduling
public class ScheduledService {
    @Scheduled(cron = "0/5 * * * * *")
    public void scheduled(){
        log.info("=====>>>>>使用cron  {}",System.currentTimeMillis());
    }
    @Scheduled(fixedRate = 5000)
    public void scheduled1() {
        log.info("=====>>>>>使用fixedRate{}", System.currentTimeMillis());
    }
    @Scheduled(fixedDelay = 5000)
    public void scheduled2() {
        log.info("=====>>>>>fixedDelay{}",System.currentTimeMillis());
    }

```

在主类上使用``@EnableScheduling``注解开启对定时任务的支持，然后启动项目
可以看到三个定时任务都已经执行，并且使同一个线程中串行执行，如果只有一个定时任务，这样做肯定没问题，当定时任务增多，如果一个任务卡死，会导致其他任务也无法执行。

多线程执行

在传统的Spring项目中，我们可以在xml配置文件添加task的配置，而在SpringBoot项目中一般使用config配置类的方式添加配置，所以新建一个AsyncConfig类

```java

@Configuration
@EnableAsync
public class AsyncConfig {
     /*
    此处成员变量应该使用@Value从配置中读取
     */
    private int corePoolSize = 10;
    private int maxPoolSize = 200;
    private int queueCapacity = 10;
    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(corePoolSize);
        executor.setMaxPoolSize(maxPoolSize);
        executor.setQueueCapacity(queueCapacity);
        executor.initialize();
        return executor;
    }
}
```

``@Configuration``：表明该类是一个配置类
``@EnableAsync``：开启异步事件的支持

然后在定时任务的类或者方法上添加@Async 。最后重启项目，每一个任务都是在不同的线程中。

补充：[在线cron表达式生成](http://qqe2.com/cron/index)

[该方式的扩展应用](https://www.cnblogs.com/mmzs/p/10161936.html)
