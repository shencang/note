# 问题解决
----
### 解决java.lang.RuntimeException: Unable to start activity Activity无法打开的问题

```java
在跑一个Android project时，出现以下错误:

/************************************************************/

FATAL EXCEPTION: main Process: com.example.leidong.myapp, PID: 4506 java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.leidong.myapp/com.example.leidong.myapp.loginAndRegister.UserRegister}: java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.

/***********************************************************/

大概主要的意思是说没法打开UserRegister这个Activity。

因此app直接没法运行，虚拟机上提示的是“Unfortunately MyAPP has stoped”。注意，此时我的AndroidManifest.xml已经声明了UserRegister的Activity，整个src代码和res中也不报任何错误。

```

#### 解决办法

    看下UserRegister.java，发现UserRegister类继承的是ActionBarActivity类而不是Activity类，于是把继承的ActionBarActivity类改成Activity类，之后再跑app，发现问题得到解决，app可以正常调试。截图见下：


### @SuppressLint(“HandlerLeak”)


碰到方法的前面和类的前面有时会出现@SuppressLint或者@SuppressWarnings这样的黄色警告，看起来很不舒服，于是上网搜集了一些相关资料。发现这些警告的出现其实是由于我们编写代码时的一些不规范的写法导致，解决这些问题其实是能提高我们程序的安全性、可用性和性能的。接下来就让我为大家一一说明。 
#### 1、@SuppressLint(“DrawAllocation”) 
* 原因：我们都知道View及其子类的OnDraw（Canvas canvas）方法会实时调用来更新界面的，然而有时我们会在onDraw（Canvas canvas）方法中实例化对象（如Paint paint=new Paint（）），这样就会影响我们程序的效率。 
* 解决办法：将这些对象改为类的成员变量。

#### 2、@SuppressWarnings(“rawtypes”)和@SuppressWarnings({ “unchecked”, “rawtypes” }) 
* 不规范写法：
```java
Class clazz = Class.forName(“android.view.Display”); 
```
* 正确写法：
```java
Class<?> clazz = Class.forName("android.view.Display");
```

#### 3、@SuppressLint(“HandlerLeak”) 

* 原因：Handler在Android中用于消息的发送与异步处理，常常在Activity中作为一个匿名内部类来定义，此时Handler会隐式地持有一个外部类对象（通常是一个Activity）的引用。当Activity已经被用户关闭时，由于Handler持有Activity的引用造成Activity无法被GC回收，这样容易造成内存泄露。 
* 解决办法：将其定义成一个静态内部类（此时不会持有外部类对象的引用），在构造方法中传入Activity并对Activity对象增加一个弱引用，这样Activity被用户关闭之后，即便异步消息还未处理完毕，Activity也能够被GC回收，从而避免了内存泄露。
```java
public static class MyHandler extends Handler {
        private WeakReference<Activity> reference
        public MyHandler(Activity activity) {
            reference = new WeakReference<Activity>(activity);
        }
        @Override
        public void handleMessage(Message msg) {
            if (reference.get() != null) {
                switch (msg.what) {
                case 0:
                    // do something...
                    break;
                default:
                    // do something...
                    break;
                }
            }
        }
```
静态内部类实现，据说这是最标准的写法。
```java
private MyHandler handler = new MyHandler(this);
    static class MyHandler extends Handler {
        WeakReference weakReference;
        public MyHandler(SecondActivity activity) {
            weakReference = new WeakReference(activity);
        }
 
        @Override
        public void handleMessage(Message msg) {
            
        }
    }
```

* 另一种情况：
* 不规范的写法：
```java
private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
 
        };
    };
```
* 正确的写法：
```java
private Handler mHandler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            return false;
        }
    });    
```
#### 4、@SuppressLint(“SimpleDateFormat”) 
* 不规范写法：
```java
 SimpleDateFormat format = new SimpleDateFormat(pattern); 
 ```
* 正确写法：
```java
SimpleDateFormat format = new SimpleDateFormat(pattern, Locale.getDefault());
```

#### 5、@SuppressLint(“DefaultLocale”) 
* 不规范写法：String lower = string.toLowerCase(); 
boolean b = “String”.toUpperCase().equals(“STRING”); 
* 正确写法：
```java
String lower = string.toLowerCase(Locale.getDefault()); 
boolean b = “String”.toUpperCase().equals(“STRING”);
```
#### 6.解决重写onTouch事件提示的警告

[【我的Android进阶之旅】解决重写onTouch事件提示的警告：onTouch should call View#performClick when a click is detected](https://blog.csdn.net/ouyang_peng/article/details/82563779)

[OnTouch关于performClick的Warning](https://blog.csdn.net/qq_32916805/article/details/78567651)